From ca82f6fb7f2388c2d2c3ff786484519c99d90511 Mon Sep 17 00:00:00 2001
From: Shiji Yang <yangshiji66@outlook.com>
Date: Thu, 9 Jan 2025 22:12:53 +0800
Subject: [PATCH 1/2] common: introduce button bootstrap mode

This is a new interactive boot mode that allows user to press buttons
to run different boot commands.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
---
 boot/Kconfig              |   5 ++
 common/Makefile           |   1 +
 common/button_bootstrap.c | 125 ++++++++++++++++++++++++++++++++++++++
 common/main.c             |   3 +
 include/button.h          |   3 +
 5 files changed, 137 insertions(+)
 create mode 100644 common/button_bootstrap.c

--- a/boot/Kconfig
+++ b/boot/Kconfig
@@ -33,6 +33,11 @@ config TIMESTAMP
 	  loaded that does not, the message 'Wrong FIT format: no timestamp'
 	  is shown.
 
+config BUTTON_BOOTSTRAP
+	bool "Run different boot commands by pressing button"
+	select BUTTON
+	select LED
+
 config BUTTON_CMD
 	bool "Support for running a command if a button is held during boot"
 	depends on CMDLINE
--- a/common/Makefile
+++ b/common/Makefile
@@ -13,6 +13,7 @@ obj-y += cli_getch.o cli_simple.o cli_re
 obj-$(CONFIG_HUSH_OLD_PARSER) += cli_hush.o
 obj-$(CONFIG_HUSH_MODERN_PARSER) += cli_hush_modern.o
 obj-$(CONFIG_AUTOBOOT) += autoboot.o
+obj-$(CONFIG_BUTTON_BOOTSTRAP) += button_bootstrap.o
 obj-$(CONFIG_BUTTON_CMD) += button_cmd.o
 obj-y += version.o
 
--- /dev/null
+++ b/common/button_bootstrap.c
@@ -0,0 +1,125 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2025 Shiji Yang <yangshiji66@outlook.com>
+ */
+
+#include <button.h>
+#include <command.h>
+#include <dm/ofnode.h>
+#include <env.h>
+#include <init.h>
+#include <led.h>
+#include <linux/delay.h>
+#include <linux/printk.h>
+#include <search.h>
+#include <u-boot/schedule.h>
+
+#define bootstrap_is_button_on(dev)	\
+	((dev) ? button_get_state(dev) == BUTTON_ON : false)
+
+#define bootstrap_set_led_state(led, state) {	\
+	if (led)				\
+		led_set_state(led, state);	\
+}
+
+static void bootstrap_led_period(struct udevice **led, u32 period)
+{
+	u32 interval = period / 2;
+
+	mdelay(interval);
+	bootstrap_set_led_state(led[0], LEDST_OFF);
+	bootstrap_set_led_state(led[1], LEDST_ON);
+
+	mdelay(interval);
+	bootstrap_set_led_state(led[0], LEDST_ON);
+	bootstrap_set_led_state(led[1], LEDST_OFF);
+}
+
+static void bootstrap_led_heartbeat(struct udevice **led, u32 period)
+{
+	u32 interval = period / 8;
+
+	for (int cnt = 0; cnt < 2; cnt++) {
+		mdelay(interval);
+		bootstrap_set_led_state(led[0], LEDST_OFF);
+		bootstrap_set_led_state(led[1], LEDST_OFF);
+
+		mdelay(interval);
+		bootstrap_set_led_state(led[0], LEDST_ON);
+		bootstrap_set_led_state(led[1], LEDST_ON);
+	}
+	mdelay(interval * 4);
+}
+
+void button_bootstrap(void)
+{
+	int idx, cnt;
+	char bootidx[16];
+	const char *envcmd, *bootcmd = NULL;
+	struct udevice *btn[2], *led[2];
+	const char *btn_label[2], *led_label[2];
+	const char *btn_propname[2] = { "boot-btn1", "boot-btn2" };
+	const char *led_propname[2] = { "boot-led1", "boot-led2" };
+
+	for (idx = 0; idx < ARRAY_SIZE(btn); idx++) {
+		btn_label[idx] = ofnode_options_read_str(btn_propname[idx]);
+		if (!btn_label[idx] || button_get_by_label(btn_label[idx], &btn[idx]))
+			btn[idx] = NULL;
+	}
+
+	if (!btn[0] && !btn[1]) {
+		pr_err("Bootstrap: failed to get button!\n");
+		return;
+	}
+
+	for (idx = 0; idx < ARRAY_SIZE(led); idx++) {
+		led_label[idx] = ofnode_options_read_str(led_propname[idx]);
+		if (!led_label[idx] || led_get_by_label(led_label[idx], &led[idx]))
+			led[idx] = NULL;
+	}
+
+	for (idx = 0; idx < ARRAY_SIZE(btn); idx++) {
+		for (cnt = 40; cnt > 0 && bootstrap_is_button_on(btn[idx]); cnt--) {
+			if (cnt > 35)
+				mdelay(50); /* debounce interval */
+			else if (cnt > 5)
+				bootstrap_led_period(led, cnt > 15 ? 100 : 200);
+			else
+				bootstrap_led_heartbeat(led, 400);
+			schedule();
+		}
+
+		if (cnt <= 35) {
+			snprintf(bootidx, sizeof(bootidx), "bootcmd_%d-%d",
+				 idx + 1, cnt > 15 ? 1 : (cnt > 5 ? 2 : (cnt > 0 ? 3 : 4)));
+			bootcmd = ofnode_options_read_str(bootidx);
+		}
+	}
+
+	if (!bootcmd)
+		return;
+
+	if (led[0] && led[1]) {
+		led_set_state(led[0], LEDST_OFF);
+		led_set_state(led[1], LEDST_ON);
+	}
+
+	if (!strcmp(bootcmd, "env init")) {
+		env_set_default("Bootstrap: Reset Environment!\n",
+				H_FORCE | H_INTERACTIVE);
+
+		envcmd = env_get("initcmd");
+		if (envcmd)
+			run_command(envcmd, CMD_FLAG_ENV);
+
+		env_save();
+	} else {
+		envcmd = env_get(bootcmd);
+		if (envcmd) {
+			printf("Bootstrap: run bootcmd '%s'...\n", bootcmd);
+			run_command(envcmd, CMD_FLAG_ENV);
+		} else {
+			printf("Bootstrap: bootcmd '%s' not defined!\n", bootcmd);
+		}
+	}
+}
--- a/common/main.c
+++ b/common/main.c
@@ -62,6 +62,9 @@ void main_loop(void)
 			efi_launch_capsules();
 	}
 
+	if (IS_ENABLED(CONFIG_BUTTON_BOOTSTRAP))
+		button_bootstrap();
+
 	process_button_cmds();
 
 	s = bootdelay_process();
--- a/include/button.h
+++ b/include/button.h
@@ -83,4 +83,7 @@ void process_button_cmds(void);
 static inline void process_button_cmds(void) {}
 #endif /* CONFIG_BUTTON_CMD */
 
+/* Press button to execute different boot commands */
+void button_bootstrap(void);
+
 #endif
